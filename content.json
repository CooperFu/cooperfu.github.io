{"meta":{"title":"Cooper Blog","subtitle":null,"description":"我心有猛虎, 细嗅蔷薇.","author":"付强","url":"http://cooperfu.github.io","root":"/"},"pages":[{"title":"关于我","date":"2015-08-07T09:17:53.000Z","updated":"2019-03-20T08:47:36.341Z","comments":true,"path":"about/index.html","permalink":"http://cooperfu.github.io/about/index.html","excerpt":"","text":"关于我 Android Developer，从事Android开发. 极客精神. Google脑残粉. 努力学习摄影中. ruby on rails 开始转向后端开发 联系方式 Tel：18518689389 WeChat:fqzw2012 github：https://github.com/cooperfu 知乎：查看我的知乎"}],"posts":[{"title":"Learn ruby","slug":"learn-ruby","date":"2016-01-25T03:40:53.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2016-01-25/learn-ruby/","link":"","permalink":"http://cooperfu.github.io/2016-01-25/learn-ruby/","excerpt":"","text":"开始学习ruby ! Fighting!##教程参考RailsGuides 安装ruby mac下已经默认集成了ruby. 如果需要自己手动安装 去ruby-lang.org下载安装. 检查是否安装成功. 命令行输入 ruby --version 安装railssudo gem install rails 如安装成功 输入 rails --version 搭建第一个ruby on rails blog刚输入的时候就发现了一个坑. 教程里写直接输入rails new blog就行了.结果运行的时候报错. 需要安装bundle. sudo bundle install --path vendor/bundle 安装之后才好用. 启动rails 服务器: rails server rails 程序的视图都存放在 app/views/ 这个目录. 想修改的话直接修改这里面的内容. 修改了里面的welcome/index.html.erb 的文件之后. 保存退出. 设置修改好的主页 在 http://localhost:3000 这里显示. 需要修改config/文件夹中的配置文件. 回到根目录. cd config/ vim routes.rb 把 root 哪一行的注释打开. :wq就保存退出. 这个时候在启动 rails server magic! vim 黑魔法 :w | !open http://localhost:3000/articles w 写 | 执行下一个命令 ! 执行shell命令 open url 直接打开浏览器并刷新","categories":[],"tags":[{"name":"ruby","slug":"ruby","permalink":"http://cooperfu.github.io/tags/ruby/"}]},{"title":"无二之旅-Android 技术栈","slug":"android-doc","date":"2016-01-22T08:25:41.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2016-01-22/android-doc/","link":"","permalink":"http://cooperfu.github.io/2016-01-22/android-doc/","excerpt":"","text":"Android 技术栈架构旅行君/无二之旅 均采用MVC架构 此模式是将应用层中的业务逻辑抽象出来,这在Android中十分重要.因为Android本身的框架将这一层与数据层耦合在了一起,一个明显的例子就是Adapter.也是官方推荐的方式. 开发环境 开发工具 Android Studio 版本控制 Git Self-hosting Github GitLab 项目依赖管理 Gradle Library Google官方support包Support Design Library 方法超过65535multidex 网络请求库retrofit rxjavaRxJava 事件总线eventbus 图片加载fresco Log输出logger 地图Mapbox 支付Ping++ 测试框架robotium 协作工具 TeambitionTeambition BearyChatBearyChat","categories":[],"tags":[]},{"title":"instant Run之后libpng error not a png file最佳解决方案","slug":"2015-01-21","date":"2016-01-21T04:09:07.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2016-01-21/2015-01-21/","link":"","permalink":"http://cooperfu.github.io/2016-01-21/2015-01-21/","excerpt":"","text":"这个问题困扰了我很久, 我从第一天升级2.0之后就迫不及待的开启instant Run. 结果直接报错. libpng error not a png file 找了半天 众说纷纭.好多说是图片不是png少了alpha通道. 图片导出来一张张重新保存就好了. 妈个鸡老子将近30张类似的图啊..一张张找累死了..而且我还不想麻烦我们设计.. 然后找到了这个: It’s metadata added by tools like Photoshop that isn’t even honored by Android. Strip it. brew install exiftool find . -path &#39;*src/main/res/*&#39; -name &#39;*.png&#39; -exec exiftool -overwrite_original -all= {} \\; 两行代码完美解决!","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://cooperfu.github.io/tags/Android/"}]},{"title":"本周放映--The Hateful Eight","slug":"2016-01-19","date":"2016-01-19T06:48:00.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2016-01-19/2016-01-19/","link":"","permalink":"http://cooperfu.github.io/2016-01-19/2016-01-19/","excerpt":"","text":"本周推荐 The Hateful Eight本周推荐来源于室友. 偶然提到昆汀大神有新片了准备回国看,因为昆汀的片子在中国基本看不了..然而今天惊喜的发现网上有资源了! 所以本着杠铃影城的宗旨, 只能放弃刘阿姨推荐的东北玩泥巴 哦不对, 印度片. 放映 《八恶人》. 关于昆汀·塔伦蒂诺昆汀·塔伦蒂诺应该不用过多介绍, 从《低俗小说》开始,到 《杀死比尔》.在到《被解救的姜戈》.说成步步精品也不足为奇. 昆汀·塔伦蒂诺从 1987 年开始拍摄第一部电影,眼看 30 年要过去，这位先生一共执导的作品寥寥可数。本次放映的正好是他的第 8 部作品《八恶人》. 他曾经说,自己只拍 10 部电影就退休,保证自己拍的每部电影都是精品.这话听起来有些耳熟，《这个杀手不太冷》的导演吕克·贝松也曾经说过这句话，不过他现在的作品已经数不清了. 关于电影本身 IMDb 8.1 豆瓣 8.5 《八恶人》讲述了美国南北战争数年后,八名身份各异的人阴差阳错地来到怀俄明州的一座山口的马车驿站,等待去往红岩镇. 但却被一场冰雪暴困在了红岩镇……一个房间里面, 八个身份不明的人, 因为一杯有毒的咖啡, 陷入一场争斗中. 当然《八恶人》不会是一部纯粹的西部片. 在一个 8 人齐聚的房间里,每个人都互相不信任，赏金猎人、女囚、黑人, 这当中没有真正的好人和坏人, 每个人都让人憎恨. 昆汀说, 这部电影有点像《落水狗》, 又有点像尤金·奥尼尔的戏剧《送冰人来了》, 不过这一切都是西部风格的. 70mm《八恶人》将在今年圣诞率先以 70mm 胶片的格式上映，在一月份才会上映数字版本. 70mm 的剧情片非常少, 在过去的很多年中, 只有保罗-托马斯-安德森的《大师》和肯尼思-布拉纳的《哈姆雷特》采用过该格式上映. 所以《八恶人》可能是 20 年来, 以 70mm 格式公映的规模最大的影片. 昆汀曾经公开表示数字电影宣判了电影的死亡，“我他妈真的不明白，为什么一个有基础的电影制作人要选择数字化”. 对于昆汀这样的痞子来说, 一定要时不时做些和好莱坞唯利是图相悖的事情, 可想而知这次采用胶片拍摄, 他内心有多么得意.","categories":[],"tags":[]},{"title":"所有的美好都与你不期而遇","slug":"2016-01-02","date":"2016-01-02T05:48:32.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2016-01-02/2016-01-02/","link":"","permalink":"http://cooperfu.github.io/2016-01-02/2016-01-02/","excerpt":"","text":"所有的美好都与你不期而遇技术2015对我来说, 是开花结果的一年 GitHub GitLab的数据好像还是那么回事儿. 2015在Android这条路上渐行渐远.从AsyncTask到RxJava, 从Universal-Image-Loader到Fresco, 从偶尔参加小型技术分享活动到Google GDG积极参与组织, 从Android Studio 0.5 到 2.0 . 技术这条路算是越来越顺. 从所谓的高手Android QQ群, 到 小范围的干货分享群, 再到 在小范围的精品技术文章内测群. 近距离的接触了很多圈子里的大牛级人物, 当你跟着几十万粉丝的大牛一起交流探讨的时候, 发现他们也并不是多么遥不可及, 每个人都很优秀, 认识你们倍感荣幸. 工作天使汇是我来北京的第一家公司. 在天使汇的时候就觉着, 如果几年后在中国财富500强中发现他们的身影我一点都不会奇怪, 每个人都很努力都很优秀. (上图左一是CEO.A轮融了4000万美刀.数据来自IT桔子) 今年跳了一次槽. 8月份跳到了无二之旅. 真是三生有幸才能和如此多三观相符并且优秀的他们共事.可能做旅行的公司都这样, 逢年过节公司的人就跟撒网一样. 近一点的日韩新马泰, 远一点的格陵兰夏威夷欧洲. 头一天还在一起工作,第二天就均匀的分布在世界的各个角落. 很喜欢公司的Slogan. 家人五一假期姐姐外甥带着爸爸去了大连. 爸爸想去大连很多年, 终于如愿. 8月份妈妈姐姐外甥来到了北京. 脱离了旅行团逆着人流顶雨爬长城. 结果上去的时候雨停了. 整个长城上面不超过20个人. 外甥因为跑太快被姐姐训斥. 委屈的拍下了这张难得的照片. 家里在县城买了一个新楼. 70多平两室一厅. 给家里打电话妈妈说, 儿子你过年回家就装修好啦. 11月份度过了自己的经济压力期. 开始固定每月帮家里还贷. 满满的幸福. 小伙伴们 两个最好的发小2015都有来京. 无一例外的都在寂静的夜谈了很多. 关于未来, 关于生活, 关于种种无奈和希望. 搬家到苹果社区. 室友来自世界各地, 英格兰 美国 印度 西班牙. 同事笑着问我:是不是每天回家跟出国一样? 我说是阿哈哈哈. 人们总会发现自己的圈子, 太高的圈子你够不着, 太低的圈子你不合群. 2015找到了自己的圈子. 一起圣诞一起狼人杀一起愉快的跨年, 谁说不能跟同事深交. 我打死你. 等待海底捞的时候跟小贝一句玩笑话: 有空帮我杠铃影院做个头图吧! 结果小贝第二天早上就给我发来了异常认真的logo+头图: 感动之余更是珍惜这些朋友. 三生有幸才能遇见你们. 剑网32015年4月建立了一个帮会 &lt;山河破&gt; . 认识了很多有爱的小伙伴. 从走路跑商30分钟神行, 到现在帮会总人数161, 在线峰值达到33人. 离不开每个人的功劳. 由于工作太忙现充需要. 转交帮主并AFK. 希望帮会小伙伴们不要怪我. 江湖不见. 我的20152015对我来说, 是缤纷多彩的一年. 用数字来量化,大概是: 增重了10kg. 来到了70kg的健康体重.开通了微信公众号推送了2篇文章,阅读量260;去了5个城市,读了20+本书,看了100+部电影;听了1800+首音乐,换了2次发型;跑步100+km,尝试了20+不同的餐厅;新学会了500+新单词,练习了2种乐器;培养了3种兴趣爱好,结交N个好友; 等待一个对的人. 鞠躬.","categories":[],"tags":[]},{"title":"本周推荐--时空恋旅人(About Time)","slug":"1228","date":"2015-12-28T06:23:13.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-12-28/1228/","link":"","permalink":"http://cooperfu.github.io/2015-12-28/1228/","excerpt":"","text":"本周推荐–时空恋旅人(About Time)本周推荐电影来源于阿九. 给你们感受一下.. 电影评分 豆瓣 8.6 iMDb 7.8 剧情简介Tim（多姆纳尔·格利森 Domhnall Gleeson 饰）21岁了，他的老爸（比尔·奈伊 Bill Nighy 饰）告诉他，他们家族的男人都有时光旅行的超能力，可以回到过去。于是Tim将信就疑地试了一下，回到了夏天，在那里他试图改变和暗恋对象的关系，却发现怎么穿越时空都不能让不爱你的人爱上你。之后Tim来到了伦敦，成为了一个律师。他爱上了一个漂亮的姑娘Mary（瑞秋·麦克亚当斯 Rachel McAdams 饰），他通过几次时空旅行，努力地想成为Mary的男朋友。再后来，他又试图通过时光旅行，去挽回一场失败的话剧，去改善妹妹的生活，去更好地和亲人、朋友相处，度过生命中的每一天。 ##一些影评 排片时间本周三晚上8点准时开播. 一些说明 尽量播放一些适合大家看的冷门佳片. 暂定每周三开门,没想着收钱所以来之前请吃完阿姨.不收门票. 播放影片期间请尽量尊重他人尊重自己. 免费提供瓜子饮料矿泉水(等等.. 推荐影片请私聊,如果都有推荐我会发布公共号投票,一切按照得票数来. 本篇文章只对内.请勿转载收藏舔屏爱上我.","categories":[],"tags":[{"name":"电影","slug":"电影","permalink":"http://cooperfu.github.io/tags/电影/"}]},{"title":"老炮儿--影评","slug":"2015-12-25","date":"2015-12-25T15:32:21.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-12-25/2015-12-25/","link":"","permalink":"http://cooperfu.github.io/2015-12-25/2015-12-25/","excerpt":"","text":"关于这篇影评很久没有写影评了.或者说, 很久没有好电影让我觉着值得写影评了.今天这部电影.最后管虎的名字出现后,有几个人在鼓掌, 然后带动了半个影厅,都在给这部电影鼓掌.这是很久没见过的景象.出了电影院给小伙伴们的反馈是: 所以, 有了想写一篇影评的冲动. 缘起最开始知道这部电影, 是通过邓超–&gt;金马奖–&gt;没去领奖–&gt;冯小刚在工体.当时的反应大概是..卧槽好大牌呀.金马奖都不自己去.然后看到了这张图. 看到这张图之后发现 , 这绝对是个有故事的电影 , 连上映都没上 , 就直接拿了个金马奖..冯小刚这种表情就像是一个普通的讲故事大叔.操着沙哑的嗓音静静的唱着.心里暗暗决定上映了一定要去看. 关于电影本身老炮儿. 在北京话是指,整天无所事事遛鸟撩闲的混混儿. 六爷整天活在胡同里,邻里街坊都叫他 六哥. 在他的世界里, 打抱不平惩奸除恶. 凡事呢,得论一个规矩. 过这徒有其表每天主持公道的日子.然而他并不知道外面的世界已经天翻地覆. 看的时候掉了三次眼泪: 第一次是李易峰和冯小刚在酒馆喝酒那场对手戏.冯小刚趴在桌子上没法言语.浑身颤抖; 第二次是父子俩坐出租车回来,冯小刚戴上墨镜流眼泪那一刻; 第三次是整个影片的最后一幕, 倒下了,额头全是汗的站起来.扭曲着脸往前冲. 仿佛这个故事就发生在身边, 电影中出现的所有场景我都去过. 什刹海冰场, 后海酒吧一条街, 拥挤的10号线, 老北京胡同, 颐和园 . 他有难去筹钱的时候，有的兄弟借了，有的兄弟施舍了，有的兄弟没借，老炮儿从头到尾没怨过谁，该谢的谢，该报恩的报恩，负了他的也只是一句淡淡的谁都不容易。曾经仗剑江湖用暴力解决一切问题的汉子，在老去之后对生活充满了深刻的理解和通融，只是血管阻塞的胸中热血仍在，满是皱纹波澜不惊的老脸下依然暗流汹涌。 觉着最精彩的还是六爷在小酒馆里和儿子谈心那场戏。六爷几度落泪，儿子却总是能找到话茬挤兑他，他实在没招，就想给儿子磕一个，真磕一个儿子也不领情，他也只能服软儿。表面看起来是爹对儿子没招儿，只能认怂，其实磕头、流泪，服软儿，都是爹对儿子的爱，但碍着面子还得端着，嘴上还得说：“就瞧不上你那弯腰端肩的二刈子样儿。” 老炮跟不上时代了,他不理解飙车夜店睡女人,他也不懂几个毛头小子以为这就是酷,这就是兄弟道义,江湖的规矩已经不在.老炮儿自己说,自己是一枚发了霉的炮仗,已经发霉了,谁知道什么时候会憋出个响来.老炮儿最后举着军刀杀向对面的时候.我真心是浑身颤抖.没落的旧时代老炮儿最讲究的是江湖的道义和尊严,但是这个新崛起的时代却让他处处难堪. 2015这一年挺有意思的.不到最后一刻永远不知道年度最佳是什么.电影的配乐,镜头转换,在我看来都是大师级.或者说完全符合我的口味.冯小刚这个金马影帝.当之无愧.","categories":[],"tags":[]},{"title":"给各种小公司的CodeReview机制建立的建议.","slug":"code-review","date":"2015-11-30T09:41:56.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-11-30/code-review/","link":"","permalink":"http://cooperfu.github.io/2015-11-30/code-review/","excerpt":"","text":"给各种小公司的CodeReview机制建立的建议.What is the Code Review维基百科官方解释 百度百科官方解释 人话版: Code Review主要是让你的代码可以更好的组织起来，更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品。 Why we do Code Review 提高代码质量; 及早发现潜在缺弦及bug. 降低事故成本; 促进团队内部知识共享,提高团队整体水平; Review过程中对于Reviewer来说,也是一种思路重构的过程. ###一些文章 腾讯员工对于Code Review的感悟 从Code Review谈如何做技术 How we do Code Review下面的是我们公司的正常流程.我们是使用自己搭建的gitlab. 如果贵公司还在用svn可以略过了 从Teambition上接到任务 请根据实际情况 新建一条分支,新功能请以feature开头,修改bug请以fix开头,; 请尽量保证多commit 多push 1次merge request; 请不要乱写commit log; 功能整体完成的时候, 发送merge request; Reviewer请交替进行.比如我提了一个merge request. 这次让daixun当我的Reviewer.下次当我再提merge request的时候,就应该找pengfei当我的Reviewer. Android Code Review 具体流程 Base on web-server rules. 打开命令行,根据Teambition的任务创建新分支: git branch feature_add_userpage 切换到当前分支并开始开发: git checkout feature_add_userpage 请尽量多的使用 git commit -m &quot;add user ok or balabala&quot; 请保证git push之前 使用了 CheckStyle插件 跑过了你修改或者创建的类. 确保 no problems. 提交到gitlab之后,使用create merge request. 写明title和desc. assign to处填写你指定谁是你这段代码的Reviewer然后SUBMIT 如果Reviewer看过了之后,审核通过就请勾选Remove source branch然后点ACCEPT 如果Reviewer看过了之后,审核不通过, 请在不通过的代码上写批注 然后CLOSE掉. 一些说明 尊重他人，就事论事，对事不对人，毕竟每个人都写过烂代码； merge request中的每一个commit log都应该可以和代码对应，方便 review； 尽量不要发太大的merge request，以免引起 Reviewer的恐慌； 建议保证一个merge request的粒度和专注，最好不要出现一个merge request里又有重构又加新feature的情况，同样容易引起Reviewer的恐慌； 提merge request之前请确保在本地或测试环境一切正常； merge request合并者与提交者不能是同一个人； merge request需从一个特定分支（分支的名字尽量能表达代码的功能）发往上游的 develop 分支； 芝兰生于空谷，不以无人而不芳. 君子修身养道，不以穷困而改志.","categories":[],"tags":[{"name":"Code Review","slug":"Code-Review","permalink":"http://cooperfu.github.io/tags/Code-Review/"}]},{"title":"Google GDG","slug":"Google-GDG","date":"2015-11-08T02:20:46.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-11-08/Google-GDG/","link":"","permalink":"http://cooperfu.github.io/2015-11-08/Google-GDG/","excerpt":"","text":"Google 应用内检索 deep link App-indexing 不一定要网页, 在google检索自己的应用, 直接跳到自己的应用. 移动出海, Google Play google developer concole可以直接进行灰度测试, 测试各种不同的icon带来的流量. 给每一种icon分配给用户%多少的流量, 方便与看反馈. 可以根据应用的段介绍的分批测试, 来看带来的应用的下载. AdMob 从 下载量 到 活跃 到 再次安装 App 从 功能性 到内容型/平台型 Android 规范开发不要给用户制造麻烦 getExternalFilesDir(Environment.DIRECTORY_DCIM); 过滤掉各种缓存 getExternalcacheFile(); 获取app里的缓存文件 不要滥用上面的API(跟应用的应用信息挂钩.清除缓存的时候会自动调用上面的API) 尽可能完善控件的职责 如果没有触摸屏的Android设备, button如果没有focus就无法选中. 如果不想让当前设备在TV设备上使用,就写一下过滤机制,","categories":[],"tags":[{"name":"Google","slug":"Google","permalink":"http://cooperfu.github.io/tags/Google/"}]},{"title":"无二之旅双十一攻略","slug":"1111","date":"2015-10-20T10:51:32.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-10-20/1111/","link":"","permalink":"http://cooperfu.github.io/2015-10-20/1111/","excerpt":"","text":"###大家好 我是Android工程师付强. 下面教大家怎么用这段代码. 首先你要有chrome浏览器 然后打开这个页面. http://www.tmall.com/wow/act/14931/1111 第一步,请确保自己是登陆状态! (随意点一个优惠劵领取,如果成功继续) 第二步,随便找个地方点击鼠标右键，选择审查元素，点击 Console 然后复制下面的代码 12345678910111213141516171819202122232425262728293031323334(function(window, document, undefined) &#123;var interval = 800;var closeDelay = 500;var index = 0;var couponLinks;var getCoupon = function() &#123;if (index &gt;= couponLinks.length) &#123;console.log(\"领完啦! 剁手的时候别找我 TAT \");return;&#125;var coponLink = couponLinks[index];coponLink.click(); index++;console.log(\"无二之旅 付强 正在帮你领取 第\" + index + \" 张\");setTimeout(getCoupon, interval);setTimeout(function() &#123;var close = document.querySelector('.mui-dialog-close');if (close != null) close.click();&#125;, closeDelay);&#125;var _scrollTop = 0;var _scrollStep = document.documentElement.clientHeight;var _maxScrollTop = document.body.clientHeight - document.documentElement.clientHeight;var autoScrollDown = setInterval(function() &#123;_scrollTop += _scrollStep;if (_scrollTop &gt; _maxScrollTop) &#123;clearInterval(autoScrollDown);couponLinks = document.querySelectorAll('.mui-act-item-yhqbtn');console.log(\"总共：\" + couponLinks.length + \"条张优惠券待领取…\");getCoupon();&#125; else &#123;document.body.scrollTop = _scrollTop;&#125;&#125;, 500);&#125;) (window, document); 这里一共这么多类别, 每个类别都有很多优惠劵.大家不要对淘宝客气=-= 我一共领取了大概300张… 谢谢大家=-= 如有不懂来找我~","categories":[],"tags":[]},{"title":"让Android应用支持超过65535方法","slug":"2015-03-13-multi-dex","date":"2015-08-07T09:35:40.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-08-07/2015-03-13-multi-dex/","link":"","permalink":"http://cooperfu.github.io/2015-08-07/2015-03-13-multi-dex/","excerpt":"","text":"让Android应用支持超过65535方法起因今天项目添加了youku的视频解码.编译的时候,出现了这个错误. Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536 这个时候我才意识到 添加了youku的sdk之后 方法数超过了65535. 那应该怎么办呢. 我在 这里 找到了答案. 第一步 在你app的build.gradle中 添加依赖: android { compileSdkVersion 21 buildToolsVersion &quot;21.1.0&quot; defaultConfig { ... minSdkVersion 14 targetSdkVersion 21 ... // 开启multidex的支持. multiDexEnabled true } ... } dependencies { compile &apos;com.android.support:multidex:1.0.0&apos; } 第二步. 让自定义的Application类继承自 MultiDexApplication. 或者自己定义的Application类，在attachBaseContext()方法中，添加MultiDex.install(this); 编译成功!","categories":[],"tags":[{"name":"BugList","slug":"BugList","permalink":"http://cooperfu.github.io/tags/BugList/"}]},{"title":"2015规划","slug":"day201501","date":"2015-02-14T08:16:02.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2015-02-14/day201501/","link":"","permalink":"http://cooperfu.github.io/2015-02-14/day201501/","excerpt":"","text":"2015一定要完成的几个目标. 完成一个自己的app然后开源. 目前还没定下来到底要写什么, 只有几个想法. 可能是工具类. 每个月至少一篇博客. 学习python.至少能达到自己想要的爬虫水平. 改善自己的作息习惯, 过年回来开始健身. 细节.2015/02/26 年初八.update. 完成一个自己的app然后开源. 暂时有两个想法,还不知道写哪个: 刚接触到记账的好处,看了看市面上的记账软件貌似没一个和我胃口, 就想自己写一个. 有一天晚上睡觉, 突然想写个类似记录自己人生的软件, 比如某些特别的日子啦, 小的什么琐事啦,拍下的满意的照片啦.都可以记录 每个月至少一篇博客. 这里说的博客是指技术类的博客. 包括但不限于android. 学习python. 因为第一个任务, 无论写哪个都需要用到Python写后端. 公司正好还有大神免费指导. 一定要好好把握这个机会.. 改善自己的作息习惯. 这个就是靠保持了. 还是赶紧把软件写出来, 然后没事发弹窗督促自己吧.. 展望 希望自己能够在2015好好的填好这历史性的一年. 付强你绝对可以的!相信自己! 好好练习Android.不要在出现自己因为什么技术细节难住超过24小时!! 好好学英语. 人在北京就好好利用这个资源. 没事找找歪果仁聊天神马的. 最低要达到看美剧不看字幕能听个大概!! 给自己加油!","categories":[],"tags":[]},{"title":"Material Design系列之 新增的Widget","slug":"material-design-02","date":"2014-07-14T10:00:53.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-07-14/material-design-02/","link":"","permalink":"http://cooperfu.github.io/2014-07-14/material-design-02/","excerpt":"","text":"RecyclerViewRecyclerView是ListView的升级版，它具备了更好的性能，且更容易使用。和ListView一样，RecyclerView是用来显示大量数据的容器，并通过复用有限数量的View，来提高滚动时的性能。当你的视图上的元素经常动态的且有规律的改变时候，可以使用RecyclerView控件。 与ListView不同的是RecyclerView现在不再负责布局，只专注于复用机制，布局交由LayoutManager来管理。 RecyclerView仍然通过Adapter来获取需要显示的对象。 要使用RecyclerView组件，创建Adapter不再继承自BaseAdapter，而是应该继承自RecyclerView.Adapter类，并且最好指定一个继承自RecyclerView.ViewHolder的范型，Adapter不再要求你返回一个View，而是一个ViewHolder。 继承自Adapter后，需要实现3个抽象方法： // 当RecyclerView需要一个ViewHolder时会回调该方法，如果有可复用的View则该方法不会得倒回调 public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i)； // 当一个View需要出现在屏幕上时，该方法会被回调，你需要在该方法中根据数据来更改视图 public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i)； // 用于告诉RecyclerView有多个视图需要显示 public int getItemCount()； 新的Adapter和原有的Adapter并没有太多的差别，只是不再需要我们写复用判断的逻辑，因为复用逻辑其实都是相似的，它已经有了自身的实现。和原有的Adapter一样，仍然可以通过notifyDataSetChanged来刷新UI，通过getItemViewType来获取对应位置的类型，但是它不再需要你指定有多少类型了，因为该方法已经能够判断出有多少类型。新增的onViewRecycled方法可以让使用者监听View被移除屏幕的时机，并且还提供了一个AdapterDataObserver的观察者，对外提供数据改变时的回调。 ViewHolder是对所有的单个item的封装，不仅包含了item需要显示的View，并且还包含和item相关的其它数据 例如：当前的position、之前的position、即将显示的position、被回收的次数、View的类型、是否处于显示中等信息。创建一个ViewHolder需要传递一个View对象，这个View就是该holder的显示视图，该View中通常会包含一些子视图，我们最好把这些子视图都记录在holder中，便于复用时设置不同的数据。 RecyclerView不再对布局进行管理，而是通过LayoutManager管理布局，我们可以通过继承自LayoutManager来实现特殊的布局，系统提供了三种常用的布局管理器： LinearLayoutManager 线性布局 GridLayoutManager 九宫格布局 StaggeredGridLayoutManager 瀑布流布局 并且每一种都可以设置横行和纵向的布局，可惜的均不能添加header，如果要添加header，我们可以在Adapter中使用不同的类型来达到该效果。 RecyclerView默认提供了item的增加和删除的动画效果，如果我们使用自定义的动画，需要继承继承RecyclerView.ItemAnimator类，时候时，通过RecyclerView.setItemAnimator()方法来设置我们自定义的动画。 CardView在实现扁平化的UI处理上，通常离不开阴影和圆角，我们通常是让美工提供一个带有阴影和圆角效果的背景图片，现在我们有了更好的实现方式，那就是CardView。 CardView实际是一个FrameLayout类的子类，它为视图提供卡片样式，并保持在不同平台上拥有统一的风格。CardView组件可以设定阴影和圆角。 我们可以使用cardElevation属性在xml布局中设置阴影效果，在代码中可以通过setCardElevation达到同样的效果。阴影的设置和Android L中的Z属性类似。 设置圆角也相当容易，在xml中通过cardCornerRadius来设置，在代码中则使用setRadius，圆角的设置和Android L中的剪裁很相似。 如果我们想设置cardview的背景，请注意使用carBackgroundColor方法，setBackgroundColor也许会影响我们的圆角效果 ToolBarToolbar是android L引入的一个新控件，用于取代ActionBar，它提供了ActionBar类似的功能，但是更灵活。不像ActionBar那么固定，Toolbar更像是一般的View元素，可以被放置在view树体系的任意位置，可以应用动画，可以跟着ScrollView滚动，可以与布局中的其他View交互。当然，你还可以用Toolbar替换掉ActionBar，只需调用Activity.setActionBar()。 为了兼容更多的设备一般我们都是通过AppCompat中的android.support.v7.widget.Toolbar来使用Toolbar。 有两种使用Toolbar的方式： 将Toolbar当作actionbar来使用。这种情况一般发生在你想利用actionbar现有的一些功能（比如能够显示菜单中的操作项，响应菜单点击事件，使用ActionBarDrawerToggle等），但是又想获得比actionbar更多的控制权限。将Toolbar当作一个独立的控件来使用，这种方式又名Standalone。如果你要将Toolbar当作actionbar来使用，你首先要去掉actionbar，最简单的方法是使用Theme.AppCompat.NoActionBar主题。或者是设置主题的属性android:windowNoTitle为true。然后在Activity的onCreate中调用setSupportActionBar(toolbar)，原本应该出现在ActionBar上的menu会自动出现在actionbar上。 Toolbar的高度、宽度、背景颜色等等一切View的属性完全取决于你，这都是因为Toolbar本质上只是个ViewGroup。将Toolbar当作一个独立的控件来使用是不需要去掉actionbar的（两者可以共存），可以使用任意主题。但是在这种情况下，menu菜单并不会自动的显示在Toolbar上，Toolbar也不会响应菜单的回调函数，如果你想让menu菜单项显示在Toolbar上，必须手动inflate menu。 toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() { @Override public boolean onMenuItemClick(MenuItem item) { // 处理menu事件 return true; } }); // 创建一个menu添加到toolbar上 toolbar.inflateMenu(R.menu.your_toolbar_menu);","categories":[],"tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://cooperfu.github.io/tags/Material-Design/"}]},{"title":"Material Design系列之 图片和颜色","slug":"material-design-03","date":"2014-07-14T10:00:53.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-07-14/material-design-03/","link":"","permalink":"http://cooperfu.github.io/2014-07-14/material-design-03/","excerpt":"","text":"图片和颜色tint属性tint属性一个颜色值，可以对图片做颜色渲染，我们可以给view的背景设置tint色值，给ImageView的图片设置tint色值，也可以给任意Drawable或者NinePatchDrawable设置tint色值。 在应用的主题中也可以通过设置 android:tint 来给主题设置统一的颜色渲染。 tint的渲染模式有总共有16种，xml文件中可以使用6种，代码中我们可以设置16种，渲染模式决定了渲染颜色和原图颜色的取舍和合成规则： Mou icon PorterDuff.Mode.CLEAR 所绘制不会提交到画布上。 PorterDuff.Mode.SRC 显示上层绘制图片 PorterDuff.Mode.DST 显示下层绘制图片 PorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。 PorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。 PorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。 PorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。 PorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。 PorterDuff.Mode.DST_OUT 取下层绘制非交集部分。 PorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分 PorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分 PorterDuff.Mode.XOR 取两层绘制非交集。两层绘制非交集。 PorterDuff.Mode.DARKEN 上下层都显示。变暗 PorterDuff.Mode.LIGHTEN 上下层都显示。变亮 PorterDuff.Mode.MULTIPLY 取两层绘制交集 PorterDuff.Mode.SCREEN 上下层都显示。 通过tint色处理的图片会原图显示出不一样的颜色，我们可以通过这种方式利用一张图片做出图片选择器的效果，让控件在按压状态下显示另外一种颜色: 通过给图片设置tint色生成另外一种图片 &lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/ring&quot; android:tintMode=&quot;multiply&quot; android:tint=&quot;#5677fc&quot; /&gt; 利用新的图片生成图片选择器 &lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/tint_bitmap&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ring&quot; /&gt; &lt;/selector&gt; Palette调色版Palette调色板，可以很方便的让我们从图片中提取颜色。并且可以指定提取某种类型的颜色。 Vibrant 鲜艳的 Vibrant dark鲜艳的暗色 Vibrant light鲜艳的亮色 Muted柔和的 Muted dark柔和的暗色 Muted light柔和的亮色 对图片取色是一个比较消耗性能的操作，其内部会对图片的像素值进来遍历以分析对比，所以我们要在异步线程中去完成。 //如果操作本来就属于后台线程，可以使用： Palette p = Palette.generate(Bitmap bitmap); //如果在主线程中，我们可以使用异步的方式： Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() { public void onGenerated(Palette palette) { } }); 当操作完成后或者异步回调后，我们就可以使用以下方式来获取对应的色值了，并且可以在没有获取到的情况下之指定默认值： p.getVibrantColor(int defaultColor); p.getDarkVibrantColor(int defaultColor); p.getLightVibrantColor(int defaultColor); p.getMutedColor(int defaultColor); p.getDarkMutedColor(int defaultColor); p.getLightMutedColor(int defaultColor); 在使用palette之前，bitmap提供获取指定位置的像素值： bitmap.getPixel(x,y) 但是该方式只能获取某一点的像素值，palette是对整个bitmap的所有像素值进行分析，并选出几个像素占比比较多的像素值，这样选择出来的色值更符合图片的整体色值。 vector矢量图矢量图也称为面向对象的图像或绘图图像，是计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。 Android L开始支持矢量图，我们可以用它来处理一些图形简单的icon，方便我们的适配。 Android L中对矢量图的支持是通过xml文件构建，通过矢量图的path描述来生成一个矢量图，对应的java对象为VectorDrawable。 下面是官方文档提供的一个矢量图，利用改文件，我们可以创建一个随意放大缩小都不会失真的心形 &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:height=&quot;300dp&quot; android:width=&quot;300dp&quot; android:viewportHeight=&quot;40&quot; android:viewportWidth=&quot;40&quot;&gt; &lt;path android:fillColor=&quot;#ff00ff&quot; android:pathData=&quot;M20.5,9.5 c-1.955,0,-3.83,1.268,-4.5,3 c-0.67,-1.732,-2.547,-3,-4.5,-3 C8.957,9.5,7,11.432,7,14 c0,3.53,3.793,6.257,9,11.5 c5.207,-5.242,9,-7.97,9,-11.5 C25,11.432,23.043,9.5,20.5,9.5z&quot;/&gt; &lt;/vector&gt; 通过path命令来进行简单的图形还是可行的，但是复杂的图形我们就需要借助工具来生成了，比如使用 Expression Design，就可以直接粘贴来自其它软件的矢量图形，然后选择导出，导出时做如后选择：文件-&gt;导出-&gt;导出属性-&gt;格式-&gt;XAML Silverlight 画布，即可得到XAML格式的矢量图形，也就是Path。 更多矢量图学习可参考：http://www.w3.org/TR/SVG11/paths.html#PathData 我们可以访问http://editor.method.ac在线制作矢量图并导出path","categories":[],"tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://cooperfu.github.io/tags/Material-Design/"}]},{"title":"Material Design系列之 Material Design简介","slug":"material-Design-04","date":"2014-07-03T08:22:53.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-07-03/material-Design-04/","link":"","permalink":"http://cooperfu.github.io/2014-07-03/material-Design-04/","excerpt":"","text":"Material Design简介Material Design是谷歌新的设计语言，谷歌希望寄由此来统一各种平台上的用户体验，Material Design的特点是干净的排版和简单的布局，以此来突出内容。 Material Design对排版、材质、配色、光效、间距、文字大小、交互方式、动画轨迹都做出了建议，以帮助设计者设计出符合Material Design风格的应用。 Material Design设计语言鼓励大家使用充满活力的鲜艳色彩，并在同一界面建议使用三种色调，并保障有一个强色调，强色一般处于处于视图最底层，例如状态栏或者actionbar。通过强色调形成鲜明的对比，更容易突出内容的重要性。对于文字色彩的取值，Material Design建议在浅色背景上采用黑色，在深色背景上采用白色。重要信息和标题采用87%透明度，次要文字采用54%透明度，而更次要的说明文字可以采用26%的透明度。对于想特别突出或者可点击的文字，建议使用强色调。不同层级的视图，可以通过阴影来凸显。对于带有操作且内容突出的区域，可以使用cardview进行隔离，对于内容不太重要或者操作比较单一的区域，可以使用分割线进行隔离。 更多详情请见Material Design文档： 中文版网站 英文版 Material Design使用作为我们开发者，最关心的还是如何在项目中使用Material Design风格： 设置应用的 targetSdkVersion 和 targetSdkVersion 为21 在values目录下的style资源文件中创建一个style，让其继承自 android:Theme.Material 在AndroidManifest中指定应用的主题或者Activity的主题为我们设定的样式 谷歌官方我们提供了三种配色风格的Material Design样式： 黑色主题 Theme.Material 明亮主题 Theme.Material.Light 明亮主题黑色ActionBar Theme.Material.Light.DarkActionBar 我们也可以继承系统提供的Material Design样式，进行配色修改： android:colorPrimaryDark 应用的主要暗色调，statusBarColor默认使用该颜色 android:statusBarColor 状态栏颜色，默认使用colorPrimaryDark android:colorPrimary 应用的主要色调，actionBar默认使用该颜色 android:windowBackground 窗口背景颜色 android:navigationBarColor 底部栏颜色 android:colorForeground 应用的前景色，ListView的分割线，switch滑动区默认使用该颜色 android:colorBackground 应用的背景色，popMenu的背景默认使用该颜色 android:colorAccent 一般控件的选种效果默认采用该颜色 android:colorControlNormal 控件的默认色调 android:colorControlHighlight 控件按压时的色调 android:colorControlActivated 控件选中时的颜色，默认使用colorAccent android:colorButtonNormal 默认按钮的背景颜色 android:textColor Button，textView的文字颜色 android:textColorPrimaryDisableOnly RadioButton checkbox等控件的文字 android:textColorPrimary 应用的主要文字颜色，actionBar的标题文字默认使用该颜色 主题不仅可以对Application和Activity使用，也可以对某一个控件单使用，或者是在xml布局中给一个根节点控件设置android:theme属性，来修改它和它所有子控件的主题。 如果我们要对特定控件实例做自定义修改，更建议大家可以通过控件自身的API进行设置修改。 Material Design兼容性Material Design主题只有在API级别为21以上才可使用，在v7支持库中提供了部分控件的Material Design主题样式，如果想使应用在android的所有版本上都能统一风格，我们可以对控件效果做自定义或者使用一些第三方的兼容包。目前最有效的做法是针对21版本创建value－21资源目录，使用Material Design风格主题，在其他版本使用v7的Theme.AppCompat.Light风格主题。","categories":[],"tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://cooperfu.github.io/tags/Material-Design/"}]},{"title":"Material Design系列之 全新的动画","slug":"material-design-01","date":"2014-07-03T08:22:53.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-07-03/material-design-01/","link":"","permalink":"http://cooperfu.github.io/2014-07-03/material-design-01/","excerpt":"","text":"全新的动画在Material Design设计中，为用户与app交互反馈他们的动作行为和提供了视觉上的连贯性。Material主题为控件和Activity的过渡提供了一些默认的动画，在android L上，允许自定义这些动画： Touch feedback 触摸反馈 Circular Reveal 圆形展示 Curved motion 曲线运动 View state changes 视图状态变化 Vector Drawables 矢量图动画 Activity transitions 活动转场 触摸反馈触摸反馈是指用户在触摸控件时的一种可视化交互，在Android L之前，通常是通过press色变来凸显，但是因为是瞬间变化的效果，不如动画生动。 在Android L使用了RippleDrawable类，用一个水波纹扩散效果在两种不同的状态间过渡。 使用Material Design样式的应用，button默认带有该效果。除了默认的效果外，系统还提供了另外两种效果，我们只把button的背景指定为： ?android:attr/selectableItemBackground ?android:attr/selectableItemBackgroundBorderless 任何view处于可点击状态，都可以使用RippleDrawable来达到水波纹特效。 我们也可以通过设置RippleDrawable的颜色属性来调节动画颜色，系统默认的颜色为主题的一个属性颜色：android:colorControlHighlight，所以我们可以通过修改该颜色值来统一修改默认的水波纹颜色。android:colorAccent可以修改checkbox的选中颜色，更多颜色设置请参考主题。 系统的三种触摸反馈都是通过xml构建的，内容如下： 默认：&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;?android:attr/colorControlHighlight&quot;&gt; &lt;item&gt; &lt;inset android:insetLeft=&quot;4dp&quot; android:insetTop=&quot;6dp&quot; android:insetRight=&quot;4dp&quot; android:insetBottom=&quot;6dp&quot;&gt; &lt;shape android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;2dp&quot; /&gt; &lt;solid android:color=&quot;?android:attr/colorButtonNormal&quot; /&gt; &lt;padding android:left=&quot;8dp&quot; android:top=&quot;4dp&quot; android:right=&quot;8dp&quot; android:bottom=&quot;4dp&quot; /&gt; &lt;/shape&gt; &lt;/inset&gt; &lt;/item&gt; &lt;/ripple&gt; ?android:attr/selectableItemBackground &lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;?android:attr/colorControlHighlight&quot;&gt; &lt;item android:id=&quot;@android:id/mask&quot;&gt; &lt;color android:color=&quot;@android:color/white&quot; /&gt; &lt;/item&gt; &lt;/ripple&gt; ?android:attr/selectableItemBackgroundBorderless &lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;?android:attr/colorControlHighlight&quot;/&gt; 圆形展示我们通常会显示或者隐藏一个view，在Android L之前，这是一个生硬瞬间变化动作，现在，有了一个新的api为此效果提供一个圆形的显示或者隐藏的动画效果。 RevealAnimator和之前的动画使用没什么区别，同样可以设置监听器和加速器来实现各种各样的特效，该动画主要用在隐藏或者显示一个view，改变view的大小等过渡效果。 通过ViewAnimationUtils.createCircularReveal来创建一个动画，该api接受5个参数： view 操作的视图 centerX 动画开始的中心点X centerY 动画开始的中心点Y startRadius 动画开始半径 startRadius 动画结束半径 沿着中心的缩小的动画Animator animator = ViewAnimationUtils.createCircularReveal(view, view.getWidth() / 2, view.getHeight() / 2, view.getWidth(), 0); animator.setInterpolator(new LinearInterpolator()); animator.setDuration(1000); animator.start(); 从左上角扩展的圆形动画Animator animator = ViewAnimationUtils.createCircularReveal(view,0,0,0,(float) Math.hypot(view.getWidth(), view.getHeight())); animator.setDuration(1000); animator.start(); 曲线运动曲线动画在Android L之前我们可以通过继承位移动画重载applyTransformation函数来实现运动轨迹算法，但是操作起来比较繁琐： 通过继承位移动画，来改写applyTransformation来修改位移的轨迹 通过继承位移动画，来改写applyTransformation来修改位移的轨迹 public class ArcTranslateAnimation extends Animation { private float mFromXValue,mToXValue,mFromYValue,mToYValue; private float mFromXDelta,mToXDelta,mFromYDelta,mToYDelta; private PointF mStart,mControl,mEnd; public ArcTranslateAnimation(float fromXValue, float toXValue, float fromYValue, float toYValue) { mFromXValue = fromXValue; mToXValue = toXValue; mFromYValue = fromYValue; mToYValue = toYValue; } protected void applyTransformation(float interpolatedTime, Transformation t) { float dx = calcBezier(interpolatedTime, mStart.x, mControl.x, mEnd.x); float dy = calcBezier(interpolatedTime, mStart.y, mControl.y, mEnd.y); t.getMatrix().setTranslate(dx, dy); } public void initialize(int width, int height, int parentWidth, int parentHeight) { super.initialize(width, height, parentWidth, parentHeight); mFromXDelta = resolveSize(ABSOLUTE, mFromXValue, width, parentWidth); mToXDelta = resolveSize(ABSOLUTE, mToXValue, width, parentWidth); mFromYDelta = resolveSize(ABSOLUTE, mFromYValue, height, parentHeight); mToYDelta = resolveSize(ABSOLUTE, mToYValue, height, parentHeight); mStart = new PointF(mFromXDelta, mFromYDelta); mEnd = new PointF(mToXDelta, mToYDelta); mControl = new PointF(mFromXDelta, mToYDelta); } private long calcBezier(float interpolatedTime, float p0, float p1, float p2) { return Math.round((Math.pow((1 - interpolatedTime), 2) * p0) + (2 * (1 - interpolatedTime) * interpolatedTime * p1) + (Math.pow(interpolatedTime, 2) * p2); } } 矢量图动画前面我们学习了矢量图，AnimatedVectorDrawable类让你能使一个矢量图动起来。矢量图动画比帧动画更平滑的展现图片的变化过程，并且无论在内存占用，还是包体积占用上都要优于帧动画。通常定义一个矢量图动画需要三步： 在drawable资源目录下定义一个矢量图 &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:height=&quot;64dp&quot; android:width=&quot;64dp&quot; android:viewportHeight=&quot;600&quot; android:viewportWidth=&quot;600&quot;&gt; &lt;group android:name=&quot;rotationGroup&quot; android:pivotX=&quot;300.0&quot; android:pivotY=&quot;300.0&quot; android:rotation=&quot;45.0&quot; &gt; &lt;path android:name=&quot;v&quot; android:fillColor=&quot;#000000&quot; android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt; &lt;/group&gt; &lt;/vector&gt; 转场动画普通转场动画所有继承自visibility类都可以作为进入、退出的过度动画。如果我们想自定义进入和退出时的动画效果，只需要继承Visibility，重载onAppear和onDisappear方法来定义进入喝退出的动画。系统提供了三种默认方式： explode 从屏幕中心移入或移出视图 slide 从屏幕边缘移入或移出视图 fade 改变视图的透明度 想在xml中指定自定义的进入、退出的过度动画需要先对动画进行定义： &lt;transition class=&quot;my.app.transition.CustomTransition&quot;/&gt; 注意：其中CustomTransition是你自定义的动画，它必须继承自Visibility。 想以普通转场动画的方式启动一个Activity，必须在startActivity函数中传递一个对象: ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity); startActivity(intent, options.toBundle()); 如果想让返回也具备转场效果，那么在返回的Activity中不要再调用finish函数，而是应该使用finishAfterTransition来结束一个Activity，该函数会等待动画执行完毕才结束该Activity。 共享转场动画当两个Activity具备某些相遇的元素时，共享转场动画将是一个非常好的选择。使用转场动画需要将相同的元素通过android:transitionName或者view.setTransitionName设置为相同的名称，这样系统才能区分出相同的元素。 共享转场动画支持以下共享元素： changeBounds 对目标视图的大小进行动画 changeClipBounds 对目标视图的剪裁大小进行动画 changeTransform 对目标视图进行缩放、旋转、位移动画 changeImageTransform 对目标图片进行缩放 通过下面的函数启动一个共享元素动画：ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity, view, &quot;name&quot;); startActivity(intent, options.toBundle()); 如果有多个共享元素，则可以通过Pair进行包装处理：ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity,Pair.create(view1, &quot;name1&quot;),Pair.create(view2, &quot;name2&quot;)); startActivity(intent,.toBundle()); 返回时如果需要具备转场动画，那么也需要用finish函数替代finishAfterTransition来结束一个Activity。 共享转场动画通常可以根据指定的元素判断出合适的转场动画效果，不需要我们做额外的处理，也可以通过之前学习的方法进行指定共享元素转场动画效果。 组合转场动画我们可以把多个转场动画进行组合，作出更具个性的转场效果，在资源文件中通过以下方式： 代码中我们可以通过TransitionSet类组合多个转场动画： 组合可以同时针对普通转场动画和共享元素转场动画。 转场动画也可以像普通动画一样设置持续时间，延期执行时间，速率插入器，以及动画的监听等。 转场动画通常是对整个布局起作用，如果我们想对某个特定的view实施转场动画，可以把该view设置为转场动画的target，这样转场动画将只对特定的view起作用。共享元素的动画的target需要指定为transitionName.","categories":[],"tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://cooperfu.github.io/tags/Material-Design/"}]},{"title":"有效地加载大尺寸位图(Loading Large Bitmaps Efficiently)","slug":"2014-06-13-load-big-image","date":"2014-06-13T09:55:02.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-06-13/2014-06-13-load-big-image/","link":"","permalink":"http://cooperfu.github.io/2014-06-13/2014-06-13-load-big-image/","excerpt":"","text":"有效地加载大尺寸位图(Loading Large Bitmaps Efficiently) 编写:JackCooper - 原文:http://developer.android.com/training/displaying-bitmaps/load-bitmap.html 图片有不同的形状与大小。在大多数情况下它们的实际大小都比需要呈现出来的要大很多。例如，系统的Gallery程序会显示那些你使用设备camera拍摄的图片，但是那些图片的分辨率通常都比你的设备屏幕分辨率要高很多。 考虑到程序是在有限的内存下工作，理想情况是你只需要在内存中加载一个低分辨率的版本即可。这个低分辨率的版本应该是与你的UI大小所匹配的，这样才便于显示。一个高分辨率的图片不会提供任何可见的好处，却会占用宝贵的(precious)的内存资源，并且会在快速滑动图片时导致(incurs)附加的效率问题。 这一课会介绍如何通过加载一个缩小版本的图片到内存中去decoding大的bitmaps，从而避免超出程序的内存限制。 读取位图的尺寸与类型(Read Bitmap Dimensions and Type)BitmapFactory 类提供了一些decode的方法 (decodeByteArray(), decodeFile(), decodeResource(), etc.) 用来从不同的资源中创建一个Bitmap. 根据你的图片数据源来选择合适的decode方法. 那些方法在构造位图的时候会尝试分配内存，因此会容易导致OutOfMemory的异常。每一种decode方法都提供了通过BitmapFactory.Options 来设置一些附加的标记来指定decode的选项。设置 inJustDecodeBounds 属性为true可以在decoding的时候避免内存的分配，它会返回一个null的bitmap，但是 outWidth, outHeight 与 outMimeType 还是可以获取。这个技术可以允许你在构造bitmap之前优先读图片的尺寸与类型。 `BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(getResources(), R.id.myimage, options); int imageHeight = options.outHeight; int imageWidth = options.outWidth; String imageType = options.outMimeType;` 为了避免java.lang.OutOfMemory 的异常，我们需要在真正decode图片之前检查它的尺寸，除非你确定这个数据源提供了准确无误的图片且不会导致占用过多的内存。 加载一个按比例缩小的版本到内存中(Load a Scaled Down Version into Memory)通过上面的步骤我们已经知道了图片的尺寸，那些数据可以用来决定是应该加载整个图片到内存中还是加载一个缩小的版本。有下面一些因素需要考虑： 评估加载完整图片所需要耗费的内存。 程序在加载这张图片时会涉及到其他内存需求。 呈现这张图片的组件的尺寸大小。 屏幕大小与当前设备的屏幕密度。 例如，如果把一个原图是1024_768 pixel的图片显示到ImageView为128_96 pixel的缩略图就没有必要把整张图片都加载到内存中。 为了告诉decoder去加载一个低版本的图片到内存，需要在你的BitmapFactory.Options 中设置 inSampleSize 为 true 。For example, 一个分辨率为2048x1536 的图片，如果设置 inSampleSize 为4，那么会产出一个大概为512x384的bitmap。加载这张小的图片仅仅使用大概0.75MB，如果是加载全图那么大概要花费12MB(前提都是bitmap的配置是 ARGB_8888). 下面有一段根据目标图片大小来计算Sample图片大小的Sample Code: public static int calculateInSampleSize( BitmapFactory.Options options, int reqWidth, int reqHeight) { // Raw height and width of image final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) { final int halfHeight = height / 2; final int halfWidth = width / 2; // Calculate the largest inSampleSize value that is a power of 2 and keeps both // height and width larger than the requested height and width. while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) { inSampleSize *= 2; } } return inSampleSize; } Note: 设置inSampleSize为2的幂是因为decoder最终还是会对非2的幂的数进行向下处理，获取到最靠近2的幂的数。详情参考inSampleSize的文档。 为了使用这个方法，首先需要设置 inJustDecodeBounds 为 true, 把options的值传递过来，然后使用 inSampleSize 的值并设置 inJustDecodeBounds 为 false 来重新Decode一遍。 public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) { // First decode with inJustDecodeBounds=true to check dimensions final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); } 使用上面这个方法可以简单的加载一个任意大小的图片并显示为100*100 pixel的缩略图形式。像下面演示的一样: mImageView.setImageBitmap( decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100)); 你可以通过替换合适的BitmapFactory.decode* 方法来写一个类似的方法从其他的数据源进行decode bitmap。","categories":[],"tags":[{"name":"译文","slug":"译文","permalink":"http://cooperfu.github.io/tags/译文/"}]},{"title":"创建抽屉式导航(navigation drawer)","slug":"2014-05-09-native-drawer","date":"2014-05-09T09:57:29.000Z","updated":"2017-05-19T19:06:28.000Z","comments":true,"path":"2014-05-09/2014-05-09-native-drawer/","link":"","permalink":"http://cooperfu.github.io/2014-05-09/2014-05-09-native-drawer/","excerpt":"","text":"创建抽屉式导航(navigation drawer) 原文: http://developer.android.com/training/implementing-navigation/nav-drawer.html Navigation drawer是一个在屏幕左侧边缘显示导航选项的面板。大部分时候是隐藏的，当用户从屏幕左侧划屏，或在top level模式的app中点击action bar中的app图标时，才会显示。 这节课叙述如何使用Support Library中的DrawerLayout API，来实现navigation drawer。 Navigation Drawer Design：在你决定在你的app中使用Navigation Drawer之前，你应该先理解在Navigation Drawer design guide中定义的使用情况和设计准则。 创建一个Drawer Layout要添加一个navigation drawer，在你的用户界面layout中声明一个用作root view(根视图)的DrawerLayout对象。在DrawerLayout中为屏幕添加一个包含主要内容的view(当drawer隐藏时的主layout)，和其他一些包含navigation drawer内容的view。 例如，下面的layout使用了有两个子视图(child view)的DrawerLayout:一个FrameLayout用来包含主要内容(在运行时被Fragment填入)，和一个navigation drawer使用的ListView。 &lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- 包含主要内容的 view --&gt; &lt;FrameLayout android:id=&quot;@+id/content_frame&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;!-- navigation drawer(抽屉式导航) --&gt; &lt;ListView android:id=&quot;@+id/left_drawer&quot; android:layout_width=&quot;240dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:choiceMode=&quot;singleChoice&quot; android:divider=&quot;@android:color/transparent&quot; android:dividerHeight=&quot;0dp&quot; android:background=&quot;#111&quot;/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; 这个layout展示了一些layout的重要特点: 主内容view(上面的FrameLayout)，在DrawerLayout中必须是第一个子视图，因为XML的顺序代表着Z轴(垂直于手机屏幕)的顺序，并且drawer必须在内容的前端。 主内容view被设置为匹配父视图的宽和高，因为当navigation drawer隐藏时，主内容表示整个UI部分。 drawer视图(ListView)必须使用android:layout_gravity属性指定它的horizontal gravity。为了支持从右边阅读的语言(right-to-left(RTL) language)，指定它的值为”start”而不是”left”(当layout是RTL时drawer在右边显示)。 drawer视图以dp为单位指定它的宽和高来匹配父视图。drawer的宽度不能大于320dp，这样用户总能看到部分主内容。 初始化Drawer List在你的activity中，首先要做的事就是要初始化drawer的item列表。这要根据你的app内容来处理，但是一个navigation drawer通常由一个ListView组成，所以列表应该通过一个Adapter(例如ArrayAdapter或SimpleCursorAdapter)填入。 例如，如何使用一个字符串数组(string array)来初始化导航列表(navigation list): public class MainActivity extends Activity { private String[] mPlanetTitles; private DrawerLayout mDrawerLayout; private ListView mDrawerList; ... @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mPlanetTitles = getResources().getStringArray(R.array.planets_array); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerList = (ListView) findViewById(R.id.left_drawer); // 为list view设置adapter mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.drawer_list_item, mPlanetTitles)); // 为list设置click listener mDrawerList.setOnItemClickListener(new DrawerItemClickListener()); ... } } 这段代码也调用了setOnItemClickListener()来接收navigation drawer列表的点击事件。下一节会说明如何实现这个接口，并且当用户选择一个item时如何改变内容视图(content view)。 处理导航的点击事件 当用户选择drawer列表中的item，系统会调用在setOnItemClickListener()中所设置的OnItemClickListener的onItemClick()。 在onItemClick()方法中做什么，取决于你如何实现你的app结构(app structure)。在下面的例子中，每选择一个列表中的item，就插入一个不同的Fragment到主内容视图中(FrameLayout元素通过R.id.content_frame ID辨识): private class DrawerItemClickListener implements ListView.OnItemClickListener { @Override public void onItemClick(AdapterView parent, View view, int position, long id) { selectItem(position); } } /* 在主内容视图中交换fragment / private void selectItem(int position) { // 创建一个新的fragment并且根据行星的位置来显示 Fragment fragment = new PlanetFragment(); Bundle args = new Bundle(); args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position); fragment.setArguments(args); // 通过替换已存在的fragment来插入新的fragment FragmentManager fragmentManager = getFragmentManager(); fragmentManager.beginTransaction() .replace(R.id.content_frame, fragment) .commit(); // 高亮被选择的item, 更新标题, 并关闭drawer mDrawerList.setItemChecked(position, true); setTitle(mPlanetTitles[position]); mDrawerLayout.closeDrawer(mDrawerList); } @Override public void setTitle(CharSequence title) { mTitle = title; getActionBar().setTitle(mTitle); } 监听打开和关闭事件要监听drawer的打开和关闭事件，在你的DrawerLayout中调用setDrawerListener()，并传入一个DrawerLayout.DrawerListener的实现。这个接口提供drawer事件的回调例如onDrawerOpened()和onDrawerClosed()。 但是，如果你的activity包含有action bar可以不用实现DrawerLayout.DrawerListener，你可以继承ActionBarDrawerToggle来替代。ActionBarDrawerToggle实现了DrawerLayout.DrawerListener，所以你仍然可以重写这些回调。这么做也能使action bar图标和 navigation drawer的交互操作变得更容易(在下节详述)。 如Navigation Drawer design guide中所述,当drawer可见时，你应该修改action bar的内容，比如改变标题和移除与主文字内容相关的action item。下面的代码向你说明如何通过ActionBarDrawerToggle类的实例，重写DrawerLayout.DrawerListener的回调方法来实现这个目的: public class MainActivity extends Activity { private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; private CharSequence mDrawerTitle; private CharSequence mTitle; ... @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... mTitle = mDrawerTitle = getTitle(); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) { /** 当drawer处于完全关闭的状态时调用 */ public void onDrawerClosed(View view) { super.onDrawerClosed(view); getActionBar().setTitle(mTitle); invalidateOptionsMenu(); // 创建对onPrepareOptionsMenu()的调用 } /** 当drawer处于完全打开的状态时调用 */ public void onDrawerOpened(View drawerView) { super.onDrawerOpened(drawerView); getActionBar().setTitle(mDrawerTitle); invalidateOptionsMenu(); // 创建对onPrepareOptionsMenu()的调用 } }; // 设置drawer触发器为DrawerListener mDrawerLayout.setDrawerListener(mDrawerToggle); } /* 当invalidateOptionsMenu()调用时调用 */ @Override public boolean onPrepareOptionsMenu(Menu menu) { // 如果nav drawer是打开的, 隐藏与内容视图相关联的action items boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList); menu.findItem(R.id.action_websearch).setVisible(!drawerOpen); return super.onPrepareOptionsMenu(menu); } } 使用App图标来打开和关闭用户可以在屏幕左侧使用划屏手势来打开和关闭navigation drawer，但是如果你使用action bar,你也应该允许用户通过点击app图标来打开或关闭。并且app图标也应该使用一个特殊的图标来指明navigation drawer的存在。你可以通过使用上一节所说的ActionBarDrawerToggle来实现所有的这些操作。 要使ActionBarDrawerToggle起作用，通过它的构造函数创建一个实例，需要用到以下参数: Activity.html” target=”_blank”&gt;Activity用来容纳drawer。 DrawerLayout。 一个drawable资源用作drawer指示器。 标准的navigation drawer可以在Download the Action Bar Icon Pack获的 一个字符串资源描述”打开抽屉”操作(便于访问) 一个字符串资源描述”关闭抽屉”操作(便于访问) 那么，不论你是否创建了用作drawer监听器的ActionBarDrawerToggle的子类，你都需要在activity生命周期中的某些地方根据你的ActionBarDrawerToggle来调用。 public class MainActivity extends Activity { private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; ... public void onCreate(Bundle savedInstanceState) { ... mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerToggle = new ActionBarDrawerToggle( this, /* 承载 Activity */ mDrawerLayout, /* DrawerLayout 对象 */ R.drawable.ic_drawer, /* nav drawer 图标用来替换&apos;Up&apos;符号 */ R.string.drawer_open, /* &quot;打开 drawer&quot; 描述 */ R.string.drawer_close /* &quot;关闭 drawer&quot; 描述 */ ) { /** 当drawer处于完全关闭的状态时调用 */ public void onDrawerClosed(View view) { super.onDrawerClosed(view); getActionBar().setTitle(mTitle); } /** 当drawer处于完全打开的状态时调用 */ public void onDrawerOpened(View drawerView) { super.onDrawerOpened(drawerView); getActionBar().setTitle(mDrawerTitle); } }; // 设置drawer触发器为DrawerListener mDrawerLayout.setDrawerListener(mDrawerToggle); getActionBar().setDisplayHomeAsUpEnabled(true); getActionBar().setHomeButtonEnabled(true); } @Override protected void onPostCreate(Bundle savedInstanceState) { super.onPostCreate(savedInstanceState); // 在onRestoreInstanceState发生后，同步触发器状态. mDrawerToggle.syncState(); } @Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); mDrawerToggle.onConfigurationChanged(newConfig); } @Override public boolean onOptionsItemSelected(MenuItem item) { // 将事件传递给ActionBarDrawerToggle, 如果返回true，表示app 图标点击事件已经被处理 if (mDrawerToggle.onOptionsItemSelected(item)) { return true; } // 处理你的其他action bar items... return super.onOptionsItemSelected(item); } ... }","categories":[],"tags":[{"name":"译文","slug":"译文","permalink":"http://cooperfu.github.io/tags/译文/"}]}]}